# Отчет по курсовому проекту

## по курсу "Логическое программирование"

### студент: Москвин Артём Артурович

## Результат проверки

Вариант задания:

- [x] стандартный, без NLP (на 3)
- [ ] стандартный, с NLP (на 3-4)
- [ ] продвинутый (на 3-5)

| Преподаватель  | Дата | Оценка |
| -------------- | ---- | ------ |
| Сошников Д.В.  |      |        |
| Левинская М.А. |      |        |

## Введение

Я научился создавать и обрабатывать генеалогические деревья в формате GEDCOM, писать парсер для обработки GEDCOM файла в набор предикатов, а также улучил понимание языка Prolog.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM.
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog
3. Реализовать предикат проверки/поиска золовки
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве

## Получение родословного дерева

В качестве информации для создания родословного дерева я использовал генеалогическое дерево своей семьи.

## Конвертация родословного дерева

Для написания парсера GEDCOM файла я использовал язык Python, так как в нем удобно реализована работа со строками.

Изначально я обрабатываю всех людей находящихся в дереве и добавляю в ассоциативный массив (ID:ФИ)
```python
def getPersons(rawData):
  persons = {}
  str = ""
  
  personReadFlag = False
  for line in rawData:
    if (line[0] == "0" and line[3] == "I"):
      if (personReadFlag):
        persons = addPerson(persons, str)
        str = ""
      personReadFlag = True
    if (line[0] == "0" and line[3] != "I"):
      personReadFlag = False
    if (personReadFlag):
      str += line
  persons = addPerson(persons, str)
  persons[""] = ""
  return persons
```
Затем я обрабатываю все семьи заменяя id на имена
```python
def getFamilies(rawData, persons):
  families = []
  str = ""
  f = False
  for line in rawData:
    if (line[0] == "0" and line[3] == "F"):
      if (f):
        families = addFamily(families, str, persons)
        str = ""
      f = True
    if (line[0] == "0" and line[3] != "F"):
      f = False
    if (f):
      str += line
  families = addFamily(families, str, persons)
  return families
```

После чего с готовым массивом семей составляю предикаты.
```python
def genFatherPred(families, output):
    for family in families:
      if (family[0] != ''):
        for child in family[2]:
          output.write(f"father('{family[0]}','{child}')." + '\n')  
    output.write('\n')

def genMotherPred(families, output):
    for family in families:
      if (family[1] != ''):
        for child in family[2]:
          output.write(f"mother('{family[1]}','{child}')." + '\n')  
    output.write('\n')

def genPred(families):
  output = open('output.pl', 'w')

  genFatherPred(families, output)
  genMotherPred(families, output)
```
## Предикат поиска родственника

Золовка - сестра мужа. Следовательно X является золовкой Y, если Y является женой Z и X является сестрой Z. В файле main.pl реализованы предикаты проверки жены и сестры.

```prolog
:-['output.pl'].

zolovka(X, Y):- wife(Y, Z), sister(X, Z).
```

## Определение степени родства

Данная задача является задачей поиска в графе. При этом граф задан множеством фактов `father`, `mother`. Однако этих отношений родства мало, поэтому дополнительные связи в графе будут создаваться предикатом `rel`, который описан для отношений сын, дочь, брат, сестра, отец, мать, дедушка, бабушка, внук, внучка, золовка. Эти отношения требуют определения пола для человека, который будет определяться предикатом `sex`.

```prolog
sex(X, m) :- father(X, _).
sex(X, f) :- mother(X, _).
```

При определении степени родства(что на деле является поиском) разумнее сего искать кратчайший путь, для такой задачи нужно использовать поиск в глубину и поиск в ширину.

```prolog
relative(Rel, X, Y) :- nonvar(Rel), !, dfs(Rel, Y, [X]).
relative(Rel, X, Y) :- bfs(Rel, Y, [[X]]).
```

Такая комбинация позволяет проводить поиск во все стороны.

Поиск в глубину позволяет сразу составлять ответ списком отношений. Поиск в ширину может это делать только за счет удвоения используемой памяти.

```prolog
prolong([X|T],  [Y,  X|T]) :- rel(_,  X,  Y),  not(member(Y,  [X|T])).
to_rel([],  [_]).
to_rel([R|T1],  [Y,  X|T2]) :- rel(R,  X,  Y),  to_rel(T1,  [X|T2]).

dfs([],  Y,  [Y|_]).
dfs([Rel1|Rel2],  Y,  [X|T]) :-
	rel(Rel1,  X,  Z),  not(member(Z,  [X|T])),
	dfs(Rel2,  Y,  [Z, X|T]).

bfs(R,  Y,  [[Y|T]|_]) :- to_rel(R1,  [Y|T]),  reverse(R1,  R).
bfs(R,  Y,  [[X|P]|Q1]) :-
	setof(Z,  prolong([X|P],  Z),  T),  append(Q1,  T,  Q2),  !,
	bfs(R,  Y,  Q2).
bfs(R,  Y,  [_|T]) :- bfs(R,  Y,  T).
```
## Выводы

В ходе выполнения курсовой работы, я окончательно закрепил знания полученные на курса логического программирования в течение семестра и на лабораторных работах. 

Задание поиска отношений на графе показало простоту и лакончиность решения данной проблемы на языках логического программирования.

Реализация парсера для gedcom файла показывает координальную разницу в подходе к разработке между языками декларативных и императивных парадигм.